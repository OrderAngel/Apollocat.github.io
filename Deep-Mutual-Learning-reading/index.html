<!DOCTYPE html>


<html lang="zh-Hans">


<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="记录，学习，娱乐，博客" />
   
  <meta name="description" content="四界云官" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
    Deep Mutual Learning-reading |  四界
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/greencat2.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">
  
<link rel="stylesheet" href="/css/custom.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

</html>

<body>
  <div id="app">
    
      
      <canvas width="1777" height="841"
        style="position: fixed; left: 0px; top: 0px; z-index: 99999; pointer-events: none;"></canvas>
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Deep-Mutual-Learning-reading"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Deep Mutual Learning-reading
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/Deep-Mutual-Learning-reading/" class="article-date">
  <time datetime="2021-10-03T10:26:31.000Z" itemprop="datePublished">2021-10-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BA%E6%96%87/">论文</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">34 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="论文笔记：Deep-Mutual-Learning"><a href="#论文笔记：Deep-Mutual-Learning" class="headerlink" title="论文笔记：Deep Mutual Learning"></a>论文笔记：Deep Mutual Learning</h2><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="1-logit"><a href="#1-logit" class="headerlink" title="1. logit"></a>1. logit</h2><p>logit原本是sigmoid函数的反函数。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004022202.png"></p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004021607.png"></p>
<p>而在深度学习中，logits表示最终的全连接层（网络最后一层）的输出，logit经过sigmoid或者softmax进行激活后，得到概率p。在神经网络中，大部分情况并不需要用到logit函数公式。</p>
<p>在知识蒸馏中，在二分类情况下需要用到logit函数，因为需要从神经网络黑盒输出的概率值反推logits，再用logits作为输入调节温度后重新计算概率：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004022240.png"></p>
<p>因此对于逻辑回归问题而言，logit是输出函数（p）经过logit函数的结果。</p>
<p>然而对于多分类问题使用的激活函数softmax而言，其反函数其实不是logit函数，而是log函数，继续称作logit只是习惯罢了。</p>
<p>softmax：<br><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004023129.png"></p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004022736.png"></p>
<p>总之，神经网络中的术语logits实际上跟logit函数关系不大，就是定义神经网络的一层输出结果，在该输出后一般会接一个softmax或者sigmoid激活层输出正则化后的概率。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/60751553">参考</a></p>
<h2 id="2-KD散度"><a href="#2-KD散度" class="headerlink" title="2. KD散度"></a>2. KD散度</h2><p>KL散度是两个概率分布P和Q差别的非对称性的度量（P-Q不等于Q-P）。</p>
<p>KL散度是用来度量使用基于Q的分布来编码服从P的分布的样本所需的额外的平均比特数。典型情况下，P表示数据的真实分布，Q表示数据的理论分布、估计的模型分布、或P的近似分布。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004025020.png"></p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004025059.png"></p>
<h2 id="3-梯度下降"><a href="#3-梯度下降" class="headerlink" title="3. 梯度下降"></a>3. 梯度下降</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/264189719">参考</a></p>
<h3 id="1-批量梯度下降"><a href="#1-批量梯度下降" class="headerlink" title="1). 批量梯度下降"></a>1). 批量梯度下降</h3><p>每次更新时使用所有样本。也就是说在第i次梯度下降过程中，对于θi的更新，所有样本都有贡献。</p>
<p>这个方法计算得到的是一个标准梯度，对于最优化问题、凸问题，肯定可以达到一个全局最优。</p>
<p>但是每一次更新的幅度都是比较大的。样本不多的情况下，收敛速度会很快，但是如果样本很多，每一次更新都会耗时很久。</p>
<h3 id="2-随机梯度下降"><a href="#2-随机梯度下降" class="headerlink" title="2). 随机梯度下降"></a>2). 随机梯度下降</h3><p>在每次更新时只用一个样本来更新θ。思路是用一个样本来近似所有样本。【这个样本是不是随机取的？最后是不是要用完所有样本？】</p>
<p>随机梯度下降计算的不是一个准确梯度，对于最优化问题、凸问题，虽然不是每次迭代都是向着全局最优方向，但是大方向是向着全局最优解的，最后的结果也往往在全局最优解附近。</p>
<p>这种方法速度更快，虽然不是全局最优，但有些情况下也是可以接受的。</p>
<h3 id="3-mini-batch梯度下降"><a href="#3-mini-batch梯度下降" class="headerlink" title="3). mini-batch梯度下降"></a>3). mini-batch梯度下降</h3><p>批量和随机的一种折中，每次更新时用b个样本，即使用一些样本来近似全部样本。【本文用的应该就是这个吧？】</p>
<h2 id="4-epoch，iteration，batchsize"><a href="#4-epoch，iteration，batchsize" class="headerlink" title="4. epoch，iteration，batchsize"></a>4. epoch，iteration，batchsize</h2><p>深度学习中经常看到epoch、iteration和batchsize，下面按照自己的理解说说这三个区别：</p>
<ul>
<li>batchsize：批大小。在深度学习中，一般采用SGD训练，即每次训练在训练集中取batchsize个样本训练；</li>
<li>iteration：1个iteration等于使用batchsize个样本训练一次；</li>
<li>epoch：1个epoch等于使用训练集中的全部样本训练一次；</li>
</ul>
<p>举个例子，训练集有1000个样本，batchsize=10，那么：<br>训练完整个样本集需要：<br>100次iteration，1次epoch。</p>
<h2 id="5-generalization"><a href="#5-generalization" class="headerlink" title="5. generalization"></a>5. generalization</h2><p>泛化 (generalization) 是指神经网络对未在训练 (学习) 过程中遇到的数据可以得到合理的输出。</p>
<h2 id="6-机器学习常用的评测指标"><a href="#6-机器学习常用的评测指标" class="headerlink" title="6. 机器学习常用的评测指标"></a>6. 机器学习常用的评测指标</h2><ul>
<li>Rank-n</li>
<li>Precision &amp; Recall</li>
<li>F-score</li>
<li>Map </li>
<li>CMC</li>
<li>ROC Single shot</li>
<li>Muti shot<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_42239797/article/details/93651594">详细</a></li>
</ul>
<h1 id="0-摘要"><a href="#0-摘要" class="headerlink" title="0. 摘要"></a>0. 摘要</h1><p><code>模型蒸馏</code>是一种将知识从教师网络传递到学生网络的技术。这项技术最典型的应用是强大的大型或集合网络向小型网络的转移，以便于低内存或快速执行的需求。</p>
<p>在本文中，我们提出了<code>Deep Mutual Learning</code>，在这个策略中，不再是静态的预设的教师网络向学生网络的单向传递，而是学生集合在训练过程中协作学习、互相教导。</p>
<p>实验表明，多种网络结构都可以从互学习策略中收益，实验在<code>CIFAR-100识别数据集</code>和<code>Market-1501 person re-identification 基线</code>上取得了很好的结果。</p>
<p>令人惊讶的是，我们发现：强大的教师网络不是必需的。简单学生网络间的互学习，比从强大的静态的教师网络中学习的效果更好。</p>
<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>DNN在许多问题上有最先进的表现，但是DNN的网络结构通常都非常深或者宽，并且包含大量的参数。这就引出了DNN的一个<code>缺点</code>：执行慢或者需要大量memory来存储，这个缺点限制了它在有低内存/快执行要求的app或者platform上的应用。于是，有关更小更快的model的研究开始增多。实现一个紧凑且准确的模型可以用这些方法：</p>
<ol>
<li>explicit frugal architecture design[8]</li>
<li>model compression[20]</li>
<li>pruning[13]</li>
<li>binarisation[18]</li>
<li>模型蒸馏[7]</li>
</ol>
<p>基于蒸馏的模型压缩与这样的observation[2,3]相关：1. 小网络和大网络有相同的<code>representation capacity</code>，2. 但是相比于大型网络，小网络只是更难训练和找到实现所需功能的正确参数。也就是说，限制点主要在于优化的难度而不是网络的大小[2]。为了更好的学习一个小网络，蒸馏方法起始于一个强大的（深/宽）的教师网络（或者网络集合），然后训练一个更小的学生网络去模拟教师网络[7,2,16,3]。模仿教师网络的类别概率[7]and/or 传递常规的监督学习目标外的额外信息的<code>feature representation</code>[2,19]。学习如何模仿教师网络的优化问题比直接学习目标函数更容易，小得多的学生网络可以匹配甚至超越更大的教师网络。</p>
<p>在本文中，我们探索了一种不同于模型蒸馏但是与之相关的思想——<code>mutual learning</code>。蒸馏起始于一个强大的大规模且预训练过的教师网络，然后向一个小的、未训练的学生网络单向传递知识。相反，在互学习中，我们开始于一群未训练的学生网络，这些网络同时学习如何一起解决任务。具体来说，每一个学生网络用两个损失来训练：1. 传统的监督学习损失，2. 模仿损失（就是将每个学生网络的class posterior与其他学生的类别概率相匹配）。以这样的方式训练，每个学生网络在基于peer-teaching的场景下的学习效果 比 在传统监督学习场景下单独学习的效果要好。此外，通过互学习训练的学生网络，比通过传统的从大型预训练教师网络中蒸馏训练来的学生网络的效果要好。而且，虽然传统的蒸馏要求教师网络比目标学生网络更大更强，但是事实证明，在很多情况下，几个大型网络的互学习与独立学习相比，性能也能获得提高。</p>
<p>我们所提出的互学习为何能有如此效果，其原因或许并不明显。当学习开始于所有小型且未训练的学生网络时，额外的知识来自哪里？为什么会收敛到一个好的结果，而不是像“the blind lead the blind”那样被群体思维所束缚？关于这些问题的直觉可以通过考虑以下情况而获得：每个学生主要由传统的监督学习损失来指导，这意味着他们的表现普遍提高，且他们不能像cohort一样任意漂移到群体思维中。通过监督学习，所以网络很快能对每个训练实例预测出相同的标签（正确的），但是由于每个网络的初始条件不同，他们对下一个样本最可能标签的概率估计是不同的。正是这些<code>secondary quantities</code>为蒸馏[7]和互学习提供了额外的信息。在互学习中，student cohort有效汇集了学生对下一个样本最可能类别的集体估计。根据peers来找出并匹配每个训练实例的其他最可能类别，增加了每个学生网络的<code>posterior entropy</code>[4,17]，这有助于他们收敛都一个更稳定(flatter)的最小值，对测试数据有更好的generalization。这与最近深度学习中高<code>posterior entropy</code>方案（网络参数设置）的鲁棒性研究[4,17]有关，但与盲目的正则化熵相比，对备选方案的选择更明智些。【4.8.2】</p>
<p>总之，互学习提供了一种简单有效的方法，通过与其他网络群组的合作训练来提高网络的泛化能力。我们在物体类别识别（CIFAR100[12]上的图像分类）和实例识别问题（Market1501[33]上的人物重识别）上都进行了广泛的实验。结果表明，与预先训练好的静态大网络的蒸馏相比，小的同辈网络之间的合作学习可以实现更好的性能。特别是在人的重新识别任务上，与最新的竞争者相比，使用一个用相互学习训练的更小的网络就可以获得最先进的结果。</p>
<p>此外我们还观察到：</p>
<ol>
<li>互学习可以应用于多种网络结构，以及由大小网络混合组成的异构群组(heterogeneous cohorts)；【会不会拉低大网络的训练效果？？？等下再看一下具体的实验数据】</li>
<li>随着群组中网络数量的增加，效果也会提高——这是一个很好的特性，因为可以只对小网络进行训练，多的网络可以适应给定的GPU资源，从而进行更有效的相互学习【？】；</li>
<li>它还有利于半监督学习，在有标签和无标签的数据上都激活模仿损失。</li>
</ol>
<p>最后，我们注意到，尽管我们的重点是获得一个单独的有效网络，但是整个群组也可以作为一个高效的集合模型来使用。</p>
<h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><h3 id="Model-Distillation"><a href="#Model-Distillation" class="headerlink" title="Model Distillation"></a>Model Distillation</h3><p>基于蒸馏的模型压缩方法在十年前就提出来了[3]，但是因为[7]的原因最近又重新流行了起来，[7]提出了一些为何这种方法能有效果的额外直觉——由于对higher entropy soft-targets的额外监督和正则化【？】。起初，一个常见的应用是将一个强大的模型/集合的教授网络的近似函数蒸馏到一个单独的学生神经网络中[3,7]。但是后来，这个思路被应用在将强大的但是易于训练的大型网络蒸馏到小的但是很难训练的学生网络里[19]，小网络的性能甚至能超过他们的老师。最近，蒸馏已经更系统的连接到信息学习理论[15]和SVM+[22]上——一个聪明的教师网络为学生网络提供privileged信息。<em>Zhang等人[29]在动作识别中利用了这种利用特权信息学习的模型提炼的想法：更昂贵的光流场被视为特权信息，光流CNN被用来教导运动矢量CNN。就从教师那里提炼的知识的表示而言，现有的模型通常使用教师的类概率[8]和/或特征表示[1, 19]。最近，Yim等人[27]利用了层之间的流动，计算为层之间特征图的内积</em>。在这里，我们讨论的是完全抛弃教师网络，让一群学生网络在互相蒸馏中互相教导。</p>
<h3 id="Collaborative-Learning"><a href="#Collaborative-Learning" class="headerlink" title="Collaborative Learning"></a>Collaborative Learning</h3><p>另一个相关的思想是<code>Dual Learning</code>[5]，两个跨语言翻译(cross-lingual translation)的模型进行交互式互相教学。但这只适用于这种特殊的翻译问题，在这个的问题中，一个无条件的语言内模型(unconditional within-language model)可以用于评估预测的质量，并最终提供驱动学习过程的监督。相比之下，我们的互学习方法适用于一般的分类问题。虽然关于集合的传统亮点是优先考虑多样性[12]，而我们互学习的方法减少了多样性，即所有学生通过学习互相模仿对方而变得更加相似。但是，我们的目标不是必需产生一个多样化的集合，而是要让网络能够找到一个对测试数据具有良好generalization的稳健的解决方案，这个解决方案很难通过传统的监督学习找到。<em>此外，在dual learning中，不同的模型有不同的学习任务，而在互学习中，这些任务是相同的。最近，合作学习 [Cooperative learning with visual attributes] 被提出来，为同一任务但在不同的领域联合学习多个模型。例如，识别同一组物体类别，但一个模型输入的是RGB图像，另一个输入的是深度图像。这些模型通过对象属性进行交流，这些属性是领域不变的。这也不同于相互学习，在相互学习中，所有的模型都处理相同的任务和领域。</em>。</p>
<h1 id="3-Deep-Mutual-Learning"><a href="#3-Deep-Mutual-Learning" class="headerlink" title="3. Deep Mutual Learning"></a>3. Deep Mutual Learning</h1><h2 id="3-1-Formulation"><a href="#3-1-Formulation" class="headerlink" title="3.1 Formulation"></a>3.1 Formulation</h2><p>如图是在两个网络群组上的DML，至于如何扩展到更多的网络，请参考2.3节</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004021001.png"></p>
<p>从M个类别中给定N个样本X = {xi}1:N，将对应的标签表示为Y={yi}1:N。给定神经网络θ1时，样本xi属于类别m的概率是：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004023313.png"></p>
<p>其中logit zm是神经网络θ1中softmax层的输出。【？不是输出是输入吧】</p>
<p>对于多类别的分类问题，训练网络θ1时的目标函数（损失函数）被定义为预测值和正确标签间的交叉熵错误：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004024024.png"></p>
<p>其中函数I是<code>指标函数indicator function</code>，定义如下：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004024115.png"></p>
<p>传统的监督性损失训练网络来预测训练实例的正确标签。为了提高θ1在测试实例上的<code>generalization performance</code>，我们用另外的同辈网络θ2以后验概率p2的形式来提供自己的训练经验。为了测量两个网络的预测结果p1和p2的匹配度，我们采用<code>Kullback Leibler Divergence</code>。</p>
<p>p1和p2的KL距离计算为：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004024642.png"></p>
<p>网络θ1的整体损失函数Lθ1定义为：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004024820.png"></p>
<p>类似的，θ2的目标损失函数Lθ2可以计算为：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004025200.png"></p>
<p><em>通过这种方式，每个网络既要学习正确预测训练实例的真实标签（监督损失Lc），又要学习与其同伴的概率估计相匹配（minicry loss KL）。</em></p>
<p>我们基于KL散度的模仿损失(minicry loss)是不对称的，因此两个网络是不同的。我们可以改用对称的<code>Jensen-Shannon Divergence loss</code>:</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005120821.png"></p>
<p><em>然而，我们根据实验发现，无论是使用对称还是非对称的KL损失，并没有什么区别。【？】</em></p>
<h2 id="3-2-Optimization"><a href="#3-2-Optimization" class="headerlink" title="3.2 Optimization"></a>3.2 Optimization</h2><p><em>模型蒸馏和DML最关键的区别是：在DML中，两个模型是共同合作进行优化的，两个模型的优化过程互相密切干预。</em></p>
<p>互学习策略嵌入每个基于mini-batch的模型的更新步骤中，贯穿整个训练过程。<em>这些模型使用相同的mini-batch进行学习</em>。在每个迭代中，我们计算两个模型的预测值，并根据对方的预测值更新两个网络的参数。θ1和θ2的优化是迭代进行的，直到收敛。算法1中总结了优化的细节：<br><em>如果在单独的GPU上运行，它包括这4个连续的步骤；当有两个GPU时，可以分布式训练，即在一个GPU上运行1、2，在另一个GPU上运行3、4</em></p>
<h3 id="算法1-DML"><a href="#算法1-DML" class="headerlink" title="算法1: DML"></a>算法1: DML</h3><ul>
<li><p>输入：训练集X，标签集Y，学习率γ1,t和γ2,t</p>
</li>
<li><p>初始化：不同初始条件下的模型θ1和θ2</p>
</li>
<li><p>重复：</p>
<ul>
<li><p>t=t+1</p>
</li>
<li><p>从X中随机采样数据x</p>
<ul>
<li><p>对于当前mini-batch，根据公式1更新x的预测值p1和p2【这里的x是一个还是mini-batch梯度下降中的一组—是一组】</p>
</li>
<li><p>计算<code>stochastic gradient</code>，并更新θ1：</p>
<p>  <img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004031611.png"></p>
</li>
<li><p>对于当前mini-batch，根据公式1更新x的预测值p1和p2</p>
</li>
<li><p>计算<code>stochastic gradient</code>，并更新θ2：</p>
<p>  <img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004031913.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>直到：收敛</p>
</li>
</ul>
<p>【θ1和2的更新顺序是否有讲究？有，会一定程度上影响公平，因此后续出现了更加公平的分布式训练形式，效果进一步提高】</p>
<h2 id="3-3-Extension-to-Large-Student-Cohorts"><a href="#3-3-Extension-to-Large-Student-Cohorts" class="headerlink" title="3.3 Extension to Large Student Cohorts"></a>3.3 Extension to Large Student Cohorts</h2><p>提出的DML方法可以自然的扩展到学生群组中的更多网络。给定K个网络θ1:K，优化θk的目标函数为：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004032158.png"></p>
<p>上式表明，当有K个网络时，每个学生的DML会有效的将群组中其他K-1个网络作为教师网络来提供学习经验。公式4是K=2时的一种特殊情况。注意到，我们增加了一个系数1/(K-1)来确保训练主要由监督学习的真实标签来指导。对于具有两个以上网络的DML优化时对算法1的直接拓展。它可以通过在一台设备上学习每个网络并在设备之间传递小概率向量来实现分布式。【？】</p>
<p>两个以上网络时，DML的一个有趣的备选学习策略是将其他所有K-1个网络的集合作为一个单独的教师网络来提供平均的学习经验，这将与蒸馏方法相似，但是在每个mini-batch模型更新时进行。θk的目标函数可以写作：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004033201.png"></p>
<p>在我们的实验中（4.8节），我们发现使用一个集合教师网络(DML_e)的DML策略比使用K-1个教师网络的DML策略效果要差。这是因为建立教师集合时的平均步骤(公式9)使得教师网络在正确分类上的后验概率峰值更高，从而降低了所有类别的<code>posterior entropy</code>。【？】因此，它与DML的其中一个目标——产生具有高<code>posterior entropy</code>的鲁棒解，相矛盾。</p>
<h2 id="3-4-Extension-to-Semi-supervised-Learning"><a href="#3-4-Extension-to-Semi-supervised-Learning" class="headerlink" title="3.4 Extension to Semi-supervised Learning"></a>3.4 Extension to Semi-supervised Learning</h2><p>DML可以直接扩展到半监督学习上。 在半监督学习的设置下，我们只对标记的数据激活交叉熵损失，而对所有训练数据计算基于KL距离的模仿损失。这是因为KL距离的计算不需要类别标签，所有也可以使用无标签数据。</p>
<p>将带标签数据集表示为L，将无标签数据集表示为U，X=L∪U，学习网络θ1的目标函数可以重新定义为：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005124316.png"></p>
<h1 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h1><h2 id="4-1-数据集和设置"><a href="#4-1-数据集和设置" class="headerlink" title="4.1 数据集和设置"></a>4.1 数据集和设置</h2><h3 id="4-1-1-数据集"><a href="#4-1-1-数据集" class="headerlink" title="4.1.1 数据集"></a>4.1.1 数据集</h3><p>我们实验用到4个数据集：</p>
<ul>
<li><p>ImageNet</p>
<p>包括1000个类别的1.2 million张训练图像，50000张验证图像。</p>
<ul>
<li>CIFAR-10数据集包含10个类别的大小为32x32的彩色图片，同下</li>
<li>CIFAR-100数据集包含100个类别的大小为32x32的彩色图片，数据集被划分为50000张训练图片和10000张测试图片。报告了Top-1分类精度。【？】</li>
</ul>
</li>
<li><p>Market-1501数据集在<code>person re-identification问题</code> [Person Re-Identification] 中作为benchmark广泛使用【？】。与CIFAR上的目标类别分类问题不同，re-id的目标是将不同的非重叠相机视角下的人联系起来。</p>
<p>该数据集包含了32668张图片，从6个相机视角拍摄，1501个身份(identities)，其中751个身份用于训练，750个身份用于测试。</p>
<p>根据解决此问题的最新方法[28]，我们训练网络进行751-way分类，并且用最后一个池化层的结果特征作为测试时的最近邻匹配的representation。【？】</p>
<p>这是一个比CIFAR-100更具挑战性的数据集，因为它的任务是<code>instance recognition</code>，因此更<code>fine-grained</code>，数据集更小，类别更多。为了评估，我们使用标准的<code>Cumulative Matching Characteristic (CMC) Rank-k accuracy</code>和<code>mean average precision (mAP) metrics</code>[27]。</p>
</li>
</ul>
<h3 id="4-1-2-实现细节"><a href="#4-1-2-实现细节" class="headerlink" title="4.1.2 实现细节"></a>4.1.2 实现细节</h3><p>我们在TensorFlow框架[1]下实现所有网络和训练过程，在一个NVIDIA GeForce GTX 1080 GPU上跑所有试验。</p>
<ul>
<li><p>对于CIFAR-100，我们使用[25]中的所有试验设置。具体来讲，我们使用<code>SGD with Nesterov momentum</code>，将初始学习率设置为0.1，动量设置为0.9，mini-batch大小设置为64。每60 epochs学习率下降0.1【？那不是一次就无了，确定不是0.01？】，我们训练了200个epochs。数据增广包括水平翻转和随机剪裁（每边填充4个像素，用原图中的reflections来填补缺失的元素【？】）。</p>
</li>
<li><p>对于Market-1501，我们使用<code>Adam optimisor</code>【？】，学习率lr=0.0002，β1=0.5，β2=0.999，mini-batch size=16。<code>我们训练所有模型进行100000次迭代【这里没有epoch吗？】。我们还报告了使用/未使用在ImageNet上预训练的结果。</code></p>
</li>
<li><p>对于ImageNet，我们使用<code>RMSProp</code>【？】，decay设置为0.9，mini-batch为64，初始学习率为0.1。学习率每20个epochs衰减一次，使用<code>0.16的指数率</code>。</p>
</li>
</ul>
<h3 id="4-1-3-网络"><a href="#4-1-3-网络" class="headerlink" title="4.1.3 网络"></a>4.1.3 网络</h3><p>我们实验中使用的网络包括典型学生规模的紧凑网络：Resnet-32[6]和MobileNet[8]；和典型教师规模的大型网络：Inception V1[21]和Wide ResNet WRN-28-10[25]。表1对比了CIFAR-100数据集上所有网络的参数数量：</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211004041537.png"></p>
<h2 id="4-2-CIFAR-100上的结果"><a href="#4-2-CIFAR-100上的结果" class="headerlink" title="4.2 CIFAR-100上的结果"></a>4.2 CIFAR-100上的结果</h2><p>表2比较了不同架构的2网络的DML群组在CIFAR-100数据集上的top-1准确性。从表中可以看出：</p>
<ol>
<li><code>DML-Independent</code>一栏说明：与独立学习相比，ResNet-32、MobileNet和WRN-28-10在群组中学习性能更好。</li>
<li>容量较小的网络（ResNet-32，MobileNet）通常在DML中获益更多</li>
<li>尽管WRN-28-10是一个比ResNet-32、MobileNet大得多的网络，却仍然比它小的网络的互学习训练中获益</li>
<li>与单独训练相比，大网络的群组训练仍是有益的</li>
</ol>
<p>因此，与模型蒸馏相反，我们看到，一个大型的预训练教授网络不是获益的必需，多个大型网络仍然可以从我们这个类似蒸馏的过程中获益。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005115037.png"></p>
<p><strong>此后都是正式版内容</strong></p>
<h2 id="4-3-Market-1501上的结果"><a href="#4-3-Market-1501上的结果" class="headerlink" title="4.3 Market-1501上的结果"></a>4.3 Market-1501上的结果</h2><p>在这个实验中，我们使用MobileNet in a two-network DML cohort。表3总结了在Market-1501上MobileNet带/不带DML训练时的mAP(%)和rank-1正确率(%)，并与当前最先进方法作比较。我们可以看到，在这个更具挑战性的<code>instance recognition</code>问题上，DML相比独立训练，能显著提高MobileNet的性能，无论是否用ImageNet进行预训练。还可以看到，我们使用两个MobileNet的方法显著优于当前最先进的<code>deep re-id</code>方法。值得注意的是，MobileNet是一个简单的、小型的、通用网络。相比之下，许多最近提出的deep re-id网络，诸如[31,23,34]里的网络，都具有复杂且专门设计的架构，以处理在不同相机视角下匹配人物时发生的剧烈<code>pose-changes</code>和<code>body-part mis-alignment</code>。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005170219.png"></p>
<h2 id="4-4-ImageNet上的结果"><a href="#4-4-ImageNet上的结果" class="headerlink" title="4.4 ImageNet上的结果"></a>4.4 ImageNet上的结果</h2><p>图2(a)比较了在ImageNet上，独立训练和DML训练时，MobileNet和InceptionV1的准确性。我们可以看到这两种网络结构的DML版始终比独立版的表现更好。这些结果表明，DML适用于large-scale问题。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005170605.png"></p>
<h2 id="4-5-DML分布式训练"><a href="#4-5-DML分布式训练" class="headerlink" title="4.5 DML分布式训练"></a>4.5 DML分布式训练</h2><p>为了研究训练策略对DML的影响，我们对比了两种DML variants：</p>
<ol>
<li>Sequential：根据算法1在一个GPU上训练两个网络；两个网络依次更新；</li>
<li>distributed：每一个网络在一个单独的GPU上训练，使用CPU进行KL散度通信；这样，两个网络的预测和参数可以同步更新。</li>
</ol>
<p>我们在Market-1501上使用2个MobileNet进行实验，并在图2(b)中展示了收敛和mAP结果。</p>
<p>有趣的是，DML性能可以通过分布式训练得到进一步提升。比较这两个变体，在分布式训练时两个网络变得更加<code>euqal</code>，因为他们总是有完全相同的训练迭代次数。因此，这一结果表明，当学生网络的学习进度差异最小时，他们从DML pee-teaching中获益最大。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005173150.png"></p>
<h2 id="4-6-和模型蒸馏相对比"><a href="#4-6-和模型蒸馏相对比" class="headerlink" title="4.6 和模型蒸馏相对比"></a>4.6 和模型蒸馏相对比</h2><p>由于我们的方法与模型蒸馏[8]非常相关，我们将二者作进一步的比较。表4对比了我们DML和模型蒸馏。其中教师网络(Net1)是预训练的，并为学生网络(Net2)提供固定的后验目标【soft-max】。正如预期的那样，与独立学习相比，在传统的蒸馏方法中，强大的预训练的教授网络确实提高了学生网络的性能。（1蒸馏到2，对比2独立）</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005173612.png"></p>
<p>然而，结果表明，与蒸馏方法相比，使用DML一起训练两个网络的效果更好。（1蒸馏到2，对比2DML）这意味着在互相学习的过程中，扮演教师角色的网络通过与未经训练的学生网络互动学习，实际效果比预训练的教师网络要好。</p>
<h2 id="4-7-DML-with-Large-Student-Cohorts"><a href="#4-7-DML-with-Large-Student-Cohorts" class="headerlink" title="4.7 DML with Large Student Cohorts"></a>4.7 DML with Large Student Cohorts</h2><p>之前的实验群组中都只有两个学生网络。我们接下来就研究群组中有多个学生时的DML。图3(a)展示了在Market-1501上用DML训练越来越多的MobileNets群组规模的结果。图中显示了平均mAP和标准差。从图3(a)我们可以看出，平均单个网络的性能随着DML群组中网络数量的增加而增加，因此它与独立训练的网络有差别。这表明，当与越来越多的同伴一起学习时，学生的泛化能力得到了提高。不同网络的表现也随着群组规模的扩大而更加一致，这表现在变小的标准差上。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005174750.png"></p>
<p>在训练多个网络时，一个常见的技术是将它们作为一个集合体来进行综合预测【啥？】。在图3(b)中，我们使用了与图3(a)相同的模型，但基于集合体进行预测（根据所有成员的concatenated feature进行匹配），而不是报告每个个体的平均预测结果。从结果中我们可以看到，正如预期的那样，集合预测的结果优于单个网络预测（图3（b）对比（a））。此外，集合的性能也能随着DML群组数量而增加（图3（b）DML集合，对比Independent集合）。</p>
<p>【dml_e是啥？训练时使用K-1个学生网络的集合教师版训练方式】<br>【这里b的集合是一种综合预测的方法——需要进一步查一下细节】<br>【咋串联特征】</p>
<h2 id="4-8-How-and-Why-does-DML-Work"><a href="#4-8-How-and-Why-does-DML-Work" class="headerlink" title="4.8 How and Why does DML Work?"></a>4.8 How and Why does DML Work?</h2><p>在这一节中，我们试图给出一些关于我们的深度互学习策略是如何以及为什么发挥作用的见解。</p>
<p>最近有一波关于 “Why Deep Nets Generalise”的研究[4,30,10]，这些研究提供了一些见解，比如：</p>
<ol>
<li>虽然经常有许多解决方案（深度网络参数设置）产生零训练误差，但是其中一些泛化效果比其他好[4,10]的原因是因为处于<code>wide valleys</code>而非<code>narrow crevices</code>，因此小的扰动不会使预测效果发生巨大变化；</li>
<li>深度网络在寻找这些好的解决方案方面比预期的要好[30]，但通过使深度网络偏向具有较高后验熵的解决方案，可以增强寻找稳健最小值的趋势[4,17]。【？？？】</li>
</ol>
<h3 id="4-8-1-DML-Leads-to-Better-Quality-Solutions-with-More-Robust-Minima"><a href="#4-8-1-DML-Leads-to-Better-Quality-Solutions-with-More-Robust-Minima" class="headerlink" title="4.8.1 DML Leads to Better Quality Solutions with More Robust Minima"></a>4.8.1 DML Leads to Better Quality Solutions with More Robust Minima</h3><p>考虑到这些见解，我们对DML的过程做了一些观察。首先我们注意到，在我们的实验中，网络通常完美适合训练数据：训练准确率达到100%，分类损失变得最小（例如，图4（a））。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005184323.png"></p>
<p>然而，正如我们前面所看到的，DML在测试数据上的表现更好【？】。因此，与其说DML帮助我们找到了一个better（deeper）训练损失的最小值，不如说它帮助我们找到了一个wider/更robust的最小值，可以更好地推广到测试数据。</p>
<p>受[4, 10]的启发，我们进行了一个简单的测试，以分析使用MobileNet在CIFAR-100上发现的最小值的稳健性。对于DML和独立模型，我们比较了在每个模型参数中加入标准差为σ的独立高斯噪声前后所学模型的训练损失。我们看到，两个最小值的深度是一样的（图4(b)），但是在加入这个扰动后，独立模型的训练损失跳升了，而DML模型的损失增加得更少。这表明，DML模型找到了一个更宽的最小值，这有望提供更好的泛化性能[4,17]。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005191157.png"></p>
<h3 id="4-8-2-How-a-Better-Minima-is-Found"><a href="#4-8-2-How-a-Better-Minima-is-Found" class="headerlink" title="4.8.2 How a Better Minima is Found"></a>4.8.2 How a Better Minima is Found</h3><p>当要求每个网络与其同伴的概率估计相匹配时，不匹配：一个给定网络预测zero和该网络教师/同伴的预测 non-zero，会受到很大的惩罚【非零？】。因此，DML的总体效果是，每个网络单独将一个<code>小mass</code>放在一小部分的次要概率，而DML中的所有网络倾向于汇总他们对次要概率的预测，并且</p>
<ol>
<li>总体上将更多mass放在了次要概率上</li>
<li>对更多有区分度的次要概率赋予了非零的mass</li>
</ol>
<p>【和蒸馏的soft思路有点像】</p>
<p>我们通过比较在CIFAR-100上由DML训练的ResNet-32模型与独立训练的ResNet-32模型，所得到的<code>top-5 highest ranked classes</code>来说明这一效果，见图4（c）。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005191553.png"></p>
<p>对于每个训练样本，根据模型产生的后验概率对前5个类进行排序（第1类是真正的类，第2类是第二大可能的类，等等）。在这里我们可以看到，独立训练时对Top-1以下概率的mass分配比DML衰减得更快。这可以通过DML训练的模型和独立训练的模型的所有训练样本的平均熵值来量化，分别为<code>1.7099</code>和<code>0.2602</code>。因此，我们的方法与<code>entropy regularisation-based approaches</code>[4,17]有联系，可以找到<code>wide minima</code>【？】，但是我们的方法是通过对 “reasonable”的备选方案进行<code>mutual probability matching</code>，而不是盲目的选择<code>high-entropy</code>偏好。</p>
<p>表5进一步显示，DML与基于熵的正则化方法[4]相比，是更有效的学习更泛化模型的方法（DML相比于独立，熵）。</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005192451.png"></p>
<p>【Single-Query results？表5是个啥玩意？？？】</p>
<h3 id="4-8-3-DML-with-Ensemble-Teacher"><a href="#4-8-3-DML-with-Ensemble-Teacher" class="headerlink" title="4.8.3 DML with Ensemble Teacher"></a>4.8.3 DML with Ensemble Teacher</h3><p>在DML中，不论群组里有多少学生，每个学生都由所有同组的其他学生独立教导（公式（8））。在第3.3节中，讨论了另一种DML策略（DML_e），即要求每个学生与<code>群组中所有其他学生的集合</code>的预测相匹配（公式（9））。</p>
<p>人们有理由期待这种方法会更好：因为集合预测比单个预测要好，它应该提供一个cleaner、stronger的教学信号——更像传统的蒸馏法。</p>
<p>但在实践中，集合教学结果更差（见图3）。通过分析集合教学与同伴教学的教学信号，集合的目标相比同伴的目标在真实标签上的峰值要尖锐得多，导致DML的预测熵值（0.2805）比DML_e（0.1562）大。因此，虽然集合的<code>noise-averaging property</code>【？】对做出正确的预测是有效果的，但它实际上不利于提供教学信号，因为二级类概率是教学信号中的突出线索。拥有高熵的后验可以使得模型训练的解决方案更加稳健。</p>
<h2 id="4-9-DML使模型更相似？"><a href="#4-9-DML使模型更相似？" class="headerlink" title="4.9 DML使模型更相似？"></a>4.9 DML使模型更相似？</h2><p>我们知道，在相同的训练目标下，对于DML群组中的不同模型，预测的类别后验会很相似。问题是，这些模型是否也会产生相似的特征，特别是当模型具有相同的架构时？</p>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005210045.png"></p>
<p>图5展示了两个MobileNets在Market-1501测试集上的特征分布的<code>t-SNE可视化</code>【？】。我们可以看到，无论是有还是没有DML，两个MobileNets确实产生了不同的特征，表明得到了不同的模型。这有助于解释为什么DML群组中的不同模型可以互相教导：每个人都学到了别人没有学到的东西。</p>
<p>我们注意到，在一些模型蒸馏的研究中 [1, 19]中，加入了一个<code>feature distance loss</code>，以迫使学生网络在相应层产生与教师相似的特征。当教师是预训练且固定，而学生的目的是模仿教师时，这是有意义的。然而，在DML中，校准internal representations不同的DML模型会减少群组的多样性，从而损害每个网络教导同伴的能力。</p>
<p>表5显示，when a feature L2 loss is introduced，DML变得不那么有效（DML对比DML，L2）。【在两个模型之间引入L2损失，就是减小两个网络的特征距离】</p>
<p>【KD散度的作用不是拉近距离吗—是，但不是拉近中间层提取的特征的距离，而是拉近预测结果的距离】</p>
<h2 id="4-10-半监督学习"><a href="#4-10-半监督学习" class="headerlink" title="4.10 半监督学习"></a>4.10 半监督学习</h2><p>我们最后在CIFAR-100和Market-1501中探索半监督学习。</p>
<p>对于CIFAR-100，我们随机选择训练集每个类别的一个子集（从10%到100%）作为有标签的数据，其余的作为无标签数据。对于Market1501，我们随机选择M个身份作为有标签的数据，M从100到751不等。</p>
<p>实验以3种不同的训练策略进行：</p>
<ol>
<li>只用单一网络对标签的数据进行训练；</li>
<li>只用DML对有标签的数据进行训练（DML-labelled）；</li>
<li>用DML对所有数据进行训练，其中分类损失只对标记数据进行计算，而KL损失则对所有训练数据进行计算（DML-all）</li>
</ol>
<p><img src="https://raw.githubusercontent.com/OrderAngel/Picture/main/study/paper/20211005221720.png"></p>
<p>从图6的结果中，我们可以看出：</p>
<ol>
<li>用DML训练两个网络都比单独训练的一个网络表现要好——这点和以前一样，但现在有不同数量的带标签数据。</li>
<li>与只对标签数据添加DML（DML-labelled）相比，DML-all通过使用基于KL-distance的模仿损失来利用未标记的数据，进一步提高了性能。当标记数据的百分比较小时，改善幅度更大。这证实了DML对监督和半监督的学习场景都有好处。</li>
</ol>
<h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><p>我们提出了一种简单且普遍适用的方法，通过在有peers的群组中训练深度神经网络并进行相互蒸馏来提高其性能。通过这种方法，我们可以获得compact的网络，其性能比那些从强大但静态的教师中蒸馏出来的网络更好。DML的一个应用是获得紧凑、快速和有效的网络。</p>
<p>我们还表明，这种方法也有希望提高大型强大网络的性能，以这种方式训练的网络群组可以组合成一个集合体，进一步提高性能。</p>
<h1 id="6-思考"><a href="#6-思考" class="headerlink" title="6. 思考"></a>6. 思考</h1><ol>
<li>个人理解：互学习本质上还是soft-target在起作用。和KD对比一下，两种soft-target来源不同罢了，KD的soft-target来自于强大的教师蒸馏后的结果，互学习soft-target来源，是利用学生之间存在差异可以互相提供信息的特性。</li>
<li>为什么不能产生相似特征：如果学生都一样了会影响soft-target的供给，因为互学习的soft-target本质上来源于学生的差异性</li>
<li>PPT里加一下和知识蒸馏中学生-老师模型的异同，然后在这部分加一下以上两点的思考。<ol>
<li>另外，二者目标不同：知识蒸馏的目的是产生更强的学生，直接目的是让学生和老师越来越像，方法除了在输出上做文章还可以在中间层做文章；但是互学习的目的虽然也是产生强大的学生，但是直接目的是让学生互相帮助获得soft-target一起进步。</li>
<li>因此一些知识蒸馏的做法不能用到互学习上，2</li>
<li>为什么效果更好，可能因为知识蒸馏的教师网络还不够强大，蒸馏后的soft-target并没有直接使用多个学生来的全面，学生网络增加效果变好可以侧面验证这一点</li>
</ol>
</li>
<li>优点：不只得到了结果验证了方法有效性，还对方法有效性进行了深入的分析</li>
<li>缺点：4.7有点糊：里面的ensemble和前面方法论中提到的dml_e需要区分性说明</li>
<li>缺点：不能在无监督学习中使用，虽然文章提到互学习可以用于半监督学习，而且带标签数据占比越小效果越好，但是这个效果是有限度的，不能扩展到无监督领域。因为损失函数包括分类损失和模仿损失两部分，分类损失引导模型走向正确的分类方向；如果是无监督情况，模型只会服从于groupthink，并不能产生正确的预测。</li>
<li>发表在CVPR上的版本比arxiv上的版本更详尽，增加了imagenet上的实验，增加了对模型相似性的讨论，增加了半监督学习上的应用，增加了分布式训练部分</li>
<li> 分布式的训练实质上进一步保证学生网络的同步，因为算法1实际上是有先后顺序的</li>
</ol>
<p>   但是，为什么同步训练会更好？<br>9. 能不能用小网络对网络蒸馏来提高大网络性能？可以但没必要，因为这样需要训练大网络，但是知识蒸馏的初衷本身就是大网络难以训练。</p>
<ol start="10">
<li>共献<ol>
<li> 训练高效的小网络</li>
<li> 进一步提升大网络性能</li>
<li> 容易扩展到多网络学习</li>
<li> 容易扩展到半监督学习</li>
</ol>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.jiqizhixin.com/articles/2019-07-31-3">参考</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://apollomao.com/Deep-Mutual-Learning-reading/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%A7%91%E7%A0%94/" rel="tag">科研</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" rel="tag">论文阅读</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/ORB-SLAM-reading/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            ORB-SLAM-READING
          
        </div>
      </a>
    
    
      <a href="/V-SLAM%E6%95%B4%E7%90%864/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">V-SLAM整理4</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2022
        <i class="ri-heart-fill heart_icon"></i> 阿波罗猫
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/bluecat.svg" alt="四界"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2021/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->


<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: 'main',
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto'
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->


<script src="/js/clickBoom2.js"></script>


<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>